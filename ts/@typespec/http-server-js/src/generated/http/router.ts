// Generated by Microsoft TypeSpec

import * as http from "node:http";

import * as serverRaw from "./operations/server-raw.js";

import { parseHeaderValueParameters } from "../helpers/header.js";

import { Widgets } from "../models/all/demo-service.js";

import {
  RouterOptions,
  createPolicyChain,
  createPolicyChainForRoute,
  HttpContext,
} from "../helpers/router.js";

export interface DemoServiceRouter {
  /**
   * Dispatches the request to the appropriate service based on the request path.
   *
   * This member function may be used directly as a handler for a Node HTTP server.
   *
   * @param request - The incoming HTTP request.
   * @param response - The outgoing HTTP response.
   */
  dispatch(request: http.IncomingMessage, response: http.ServerResponse): void;
}

export function createDemoServiceRouter(
  widgets: Widgets,
  options: RouterOptions<{
    widgets: Widgets<HttpContext>;
  }> = {},
): DemoServiceRouter {
  const __onRequestNotFound_30 =
    options.onRequestNotFound ??
    ((ctx) => {
      ctx.response.statusCode = 404;
      ctx.response.setHeader("Content-Type", "text/plain");
      ctx.response.end("Not Found");
    });

  const __onInvalidRequest_31 =
    options.onInvalidRequest ??
    ((ctx) => {
      ctx.response.statusCode = 400;
      ctx.response.setHeader("Content-Type", "application/json");
      ctx.response.end(JSON.stringify({ error: "Invalid request" }));
    });

  const __onInternalError_32 =
    options.onInternalError ??
    ((ctx) => {
      ctx.response.statusCode = 500;
      ctx.response.setHeader("Content-Type", "text/plain");
      ctx.response.end("Internal server error.");
    });

  const __routePolicies_33 = options.routePolicies ?? {};

  const __routeHandlers_34 = {
    widgets_list: createPolicyChainForRoute(
      "widgetsListDispatch",
      __routePolicies_33,
      "widgets",
      "list",
      serverRaw.widgets_list,
    ),
    widgets_read: createPolicyChainForRoute(
      "widgetsReadDispatch",
      __routePolicies_33,
      "widgets",
      "read",
      serverRaw.widgets_read,
    ),
    widgets_create: createPolicyChainForRoute(
      "widgetsCreateDispatch",
      __routePolicies_33,
      "widgets",
      "create",
      serverRaw.widgets_create,
    ),
    widgets_update: createPolicyChainForRoute(
      "widgetsUpdateDispatch",
      __routePolicies_33,
      "widgets",
      "update",
      serverRaw.widgets_update,
    ),
    widgets_delete: createPolicyChainForRoute(
      "widgetsDeleteDispatch",
      __routePolicies_33,
      "widgets",
      "delete",
      serverRaw.widgets_delete,
    ),
    widgets_analyze: createPolicyChainForRoute(
      "widgetsAnalyzeDispatch",
      __routePolicies_33,
      "widgets",
      "analyze",
      serverRaw.widgets_analyze,
    ),
  } as const;

  const dispatch = createPolicyChain(
    "DemoServiceRouterDispatch",
    options.policies ?? [],
    async function (ctx, request) {
      const url = new URL(request.url!, `http://${request.headers.host}`);
      let path = url.pathname;

      if (path.length === 0) {
        return ctx.errorHandlers.onRequestNotFound(ctx);
      } else if (path.startsWith("/widgets")) {
        path = path.slice(8);
        if (path.length === 0) {
          switch (request.method) {
            case "GET":
              return __routeHandlers_34.widgets_list(ctx, widgets);
            case "POST":
              return __routeHandlers_34.widgets_create(ctx, widgets);
            default:
              return ctx.errorHandlers.onRequestNotFound(ctx);
          }
        } else if (path.startsWith("/")) {
          path = path.slice(1);
          if (path.length === 0) {
            return ctx.errorHandlers.onRequestNotFound(ctx);
          } else {
            let __id_idx = path.indexOf("/");
            __id_idx = __id_idx === -1 ? path.length : __id_idx;
            const id = path.slice(0, __id_idx);
            path = path.slice(__id_idx);
            if (path.length === 0) {
              switch (request.method) {
                case "GET":
                  return __routeHandlers_34.widgets_read(ctx, widgets, id);
                case "PATCH":
                  return __routeHandlers_34.widgets_update(ctx, widgets, id);
                case "DELETE":
                  return __routeHandlers_34.widgets_delete(ctx, widgets, id);
                default:
                  return ctx.errorHandlers.onRequestNotFound(ctx);
              }
            } else if (path.startsWith("/analyze")) {
              path = path.slice(8);
              if (path.length === 0) {
                switch (request.method) {
                  case "POST":
                    return __routeHandlers_34.widgets_analyze(ctx, widgets, id);
                  default:
                    return ctx.errorHandlers.onRequestNotFound(ctx);
                }
              } else {
                return ctx.errorHandlers.onRequestNotFound(ctx);
              }
            }
          }
        }
      }

      return ctx.errorHandlers.onRequestNotFound(ctx);
    },
  );

  const __errorHandlers_35 = {
    onRequestNotFound: __onRequestNotFound_30,
    onInvalidRequest: __onInvalidRequest_31,
    onInternalError: __onInternalError_32,
  };
  return {
    dispatch(request, response) {
      const ctx = { request, response, errorHandlers: __errorHandlers_35 };
      return dispatch(ctx, request).catch((e) =>
        __onInternalError_32(ctx, e)
      );
    },
  };
}
